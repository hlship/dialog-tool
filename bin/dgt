#!/usr/bin/env joker

;; dgt - Dialog Tool

(ns-sources
 {"net.lewisship.multi" {:url "https://raw.githubusercontent.com/hlship/multi/v1.4.0/src/net/lewisship/multi.joke"}})

(ns dgt
  "Build, run, and test interactive fiction stories in Dialog."
  (:require
   [joker.os :as os]
   [joker.string :as str]
   [joker.filepath :as f]
   [joker.time :as t]
   [joker.strconv :refer [atoi]]
   [joker.crypto :as crypto]
   [joker.hex :as hex]
   [joker.http :as http]
   [joker.better-cond :as b]
   [net.lewisship.multi :as multi :refer [defcommand]]))

(def failures-path "out/failures.edn")

(def csi "\u001b[") 
(def reset-font (str csi "m")) 
(def red-font (str csi "31m"))
(def green-font (str csi "32m"))

(def default-build-data
  {:output-format :z8
   :name (f/base (joker.os/cwd))
   :debug-sources ["/usr/local/share/dialog-if/stddebug.dg"]
   :library-sources ["/usr/local/share/dialog-if/stdlib.dg"]})

;; Utilities
(defn fail
  [msg]
  (println-err msg)
  (os/exit -1))

(defn check-result
  [label result]
  (when-not (:success result)
    (fail (str label " failed: " (:err-msg result) \n (:err result))))
  result)

(defn mkdirs
  "Recursively create a directory, if it doesn't already exist."
  [path]
  (check-result "mkdirs"
                (os/sh "mkdir" "-p" path)))

(defn rm
  [path]  
  (when (os/exists? path)
    (check-result "Remove" 
                  (os/sh "rm" path))))

(defn cache-url
  "Caches a file identified by a URL, returning the path to the cached file."
  [url]
  (b/cond
    :let [file-name (f/base url)
          sha (-> url crypto/sha1 hex/encode-string)
          cache-dir (f/join ".cache" sha)
          _ (mkdirs cache-dir)
          cache-path (f/join cache-dir file-name)]
    
    (os/exists? cache-path)
    cache-path
    
    :let [response (http/send {:url url})
          {:keys [status body]} response]
    
    (not= 200 status)
    (fail (format "Download of %s failed with status %d" url status))
    
    :else
    (do
      (spit cache-path body)
      cache-path)))

(defn expand-github 
  [lib]
  (let [{:keys [github version path]} lib]
    (when (or (nil? version)
              (nil? path))
      (throw (ex-info "Version and path are required"
                      {:lib lib})))
    (when (= "master" version)
      (throw (ex-info "Version may not be master"
                      {:lib lib})))
    
    (cache-url (str "https://raw.githubusercontent.com/"
                    github  ;; eg "hlship/threaded-conversation"
                    "/"
                    version ;; eg "v0.1"
                    "/"
                    path)))) ;; eg "lib/threaded-conversation.dg"

  (defn expand-lib
  [lib]
  (b/cond
    (string? lib)
    lib
    
    (not (map? lib))
    (throw (ex-info "Library must be string or map"
                    {:lib lib}))
    
    :let [{:keys [github]} lib]
    
    (some? github)
    (expand-github lib)
    
    :else
    (throw (ex-info "Unknown library map"
                    {:lib lib}))))

;; Commands library

;; DGT Commands

(defn glob-lib
  "If the library is a string, glob it into a seq of matches.
   Otherwise, it is a map, and wrap it in a vector."
  [lib]
  (if (string? lib)
    (f/glob lib)
    [lib]))

(defn read-build-file
  []
  (when-not (os/exists? "dialog.edn")
    (fail "No dialog.edn file in current directory."))
  
  (let [build-data (-> "dialog.edn"
                       slurp
                       read-string)
        merged (merge default-build-data build-data)]
    (reduce (fn [m k]
              (update m k #(mapcat glob-lib %)))
            merged
            [:story-sources :debug-sources :library-sources])))

;; Commands

(defn extract-sources
  [build-data for-release?]
  (let [{:keys [story-sources
                debug-sources
                library-sources]} build-data
        sources (reduce into []
                        [story-sources
                         (when-not for-release?
                           debug-sources)
                         library-sources])]
    (mapv expand-lib sources)))

(defn do-build
  [build-data options]
  (let [{:keys [output-format]
         output-name :name} build-data
        {:keys [release debug verbose]
         :or {:release true
              :debug false
              :verbose true}} options
        output-dir (str "out/"
                        (if release "release" "test"))
        output-path (str output-dir
                         "/"
                         output-name
                         "."
                         (name output-format))
        sources (extract-sources build-data release)
        args (into (cond-> ["--format" (name output-format)
                            "--output" output-path]
                     verbose (conj "--verbose"))
                   sources)]
    (mkdirs output-dir)
    (when debug
      (apply println "dialogc" args))
    (check-result "Compile" 
                  (os/exec "dialogc"
                           {:stdout *out*
                            :stderr *err*
                            :args args}))
    output-path))

(defcommand build
  "Builds a compiled version of the story"
  [debug ["-d" "--debug" "Print out the dialogc command to be executed"]
   testing ["-t" "--testing" "Compile for testing, including debug sources"]
   verbose ["-v" "--verbose" "Enable additional compiler output"]]
  (let [output (do-build (read-build-file) {:debug debug
                                            :release (not testing)
                                            :verbose verbose})]
    (println "Wrote file" output)))

(defcommand clean
  "Cleans output"
  [cache ["-c" "--cache" "Clean cache as well"]]
  (let [paths (cond-> ["out"]
                cache (conj ".cache"))]
    (check-result "Delete"
                  (apply os/sh "rm" "-rf"  paths))))

(defn find-test-paths
  []
  (let [result (os/sh "find" "tests" "-name" "*.txt")]
    (check-result "Find" result)  
    (->> result 
         :out
         str/trim
         str/split-lines
         (map str/trim))))

(defn overrides-for-test
  [test-path]
  (let [[dir _] (f/split test-path)
        override-path (f/join dir "overrides.edn")]
    (when (os/exists? override-path)
      (-> override-path slurp read-string))))

(defn execute-test
  "Executes a single test; the test path is a file containing a transcript
  to feed into the game.
  
  Returns nil on success and a failure map on failure."
  [build-data test-name test-path]
  (let [overrides (overrides-for-test test-path)
        build-data' (merge build-data overrides)
        sources (extract-sources build-data' false)
        test-input (->> test-path
                        slurp
                        str/split-lines
                        (remove str/blank?)
                        ;; Allow Dialog-style comments in the source transcript
                        (remove #(str/starts-with? % "%%"))
                        (str/join \newline))
        seed (get build-data' :seed (hash test-path))
        args (into ["--quit"
                    "--width" "80" ;; Good for comparing test output
                    "-L"
                    "--seed" (str seed)]
                   sources)
        result (check-result "Test Execution"
                             (os/exec "dgdebug" {:args args
                                                 :stdin test-input}))
        actual-output (:out result)
        blessed-path (str "tests/" test-name ".out")
        expected-output (when (os/exists? blessed-path)
                          (slurp blessed-path))
        passed? (= actual-output expected-output)]
    (when-not passed?
      (let [output-path (str "out/failed-tests/" test-name ".out")
            [output-dir _] (f/split output-path)]
        (mkdirs output-dir)
        (spit output-path actual-output)
        {:test-name test-name
         :output-path output-path
         :blessed-path blessed-path}))))

(defn write-failures 
  [failures]
  (spit failures-path
        (with-out-str (pprint failures))))

(defn bless-test
  "Show diff for test, ask user to bless

  If user approves, replace blessed file with output file, and return true.

  Otherwise, return false."
  [failure-map]
  (let [{:keys [test-name output-path blessed-path]} failure-map]
    ;; Its going to fail (with 1) because the files are not the same
    (os/exec "colordiff" {:args ["-N" "-y" "-W" "170"
                                 "--left-column"
                                 blessed-path output-path]
                          :stdout *out*
                          :stderr *err*})
    (println)
    (loop []
      (print (str "Bless " test-name " differences (" green-font "right column" reset-font ")? [yN] "))
      (let [input (read-line)]
        (cond
          (= input "y")
          (do
            (check-result "Move file" (os/sh "mv" "-f" output-path blessed-path))
            true)

          (or (= input "")
              (= input "n"))
          false

          :else
          (do
            (println (str red-font "Enter 'y' or 'n' (or hit enter)" reset-font))
            (recur)))))))

(defn do-bless
  [failures]
  (let [f (fn [failures failure-map]
            (if (bless-test failure-map)
              failures
              (conj failures failure-map)))
        failures' (reduce f [] failures)]
    (if (seq failures')
      (write-failures failures')
      (rm failures-path))))

(defcommand run-tests
  "Runs tests, capturing output, summarizing failures.

  Any failures are recorded, for use by the bless command."
  [bless ["-b" "--bless" "Immediately bless changes if there are failures"]
   :command-name "test"]
  (let [build-data (read-build-file)
        paths (find-test-paths)
        test-names (->> paths
                        (map #(str/replace % "tests/" ""))
                        (map #(str/replace % #"\.txt" "")))
        test-tuples (map vector test-names paths)
        max-width (apply max (map count test-names))
        f (fn [failures [test-name test-path]]
            (print (str/pad-left test-name " " max-width) "... ")
            (let [start-time (t/now)
                  failure (execute-test build-data test-name test-path)
                  elapsed (str/pad-left
                           (t/string (t/since start-time))
                           " " 18)]
              (if failure
                (do
                  (println (str red-font "X" reset-font) elapsed)
                  (conj failures failure))
                (do
                  (println (str green-font \u2713 reset-font) elapsed)
                  failures))))
        failures (->> test-tuples
                      (sort-by first)
                      (reduce f []))]
    (mkdirs "out")
    (if (seq failures)
      (do
        (println (str "\n" red-font (count failures) " failures" reset-font))
        (if bless
          (do-bless failures)
          (write-failures failures)))
      (do
        (println (str "\n" green-font "OK" reset-font))
        (rm failures-path)))))

(defcommand bless
  "Review failed tests and bless those where the change is acceptable"
  []
  (when-not (os/exists? failures-path)
    (fail "No failed tests to bless"))
  (-> failures-path
      slurp
      read-string
      do-bless))

(defcommand debug
  "Runs the game in the Dialog debugger"
  [overrides-path ["-o" "--overrides PATH" "Path to overrides for dialog.edn"]
   seed ["-s" "--seed NUMBER" "Initialize random number generator"
         :parse-fn atoi]
   debug ["-d" "--debug" "Print out dgdebug command to be execute"]]
  (let [ build-data (read-build-file)
        overrides (when overrides-path
                    (-> overrides-path 
                        slurp
                        read-string))
        build-data' (merge build-data overrides)
        seed' (or seed (:seed build-data))
        sources (extract-sources build-data' false)
        args (-> (cond-> ["--quit"]
                   seed' (into ["--seed" (str seed')]))
                 (into sources))]
    (when debug
      (apply println "dgdebug" args))
    (os/exec "dgdebug" {:args args
                        :stdin *in*
                        :stdout *out*
                        :stderr *err*})))

;; Main entry point.
(multi/dispatch {:tool-name "dgt"
                 :namespaces ['dgt]})